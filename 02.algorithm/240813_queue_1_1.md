# 240809_stack_2_2

## 📌 오늘 핵심 주제
- 큐(Queue)

### Queue
- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
- 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
- 선입선출(***FIFO: First In First Out***)
    - 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제
    - 머리(Front) : 저장된 원소 중 첫 번째 원소(또는 삭제된 위치)
    - 꼬리(Rear) : 저장된 원소 중 마지막 원소
- 큐의 기본 연산
    - 삽입 : enQueue
    - 삭제 : deQueue

#### 선형 큐
#### 선형 큐 이용 시의 문제점
- 선형 큐를 이용해 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 `rear = n - 1`인 상태, 즉 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨
- 해결 방법 1
    - 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동시킴
    - 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐
- 해결 방법 2
    - 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 *원형 형태의 큐*를 이룬다고 가정하고 사용

#### 원형 큐
#### 단순 연결 리스트(Linked List)
- 장점
    - 역방향 탐색 X (이중연결 리스트는 가능)
    - 탐색 O(n)
- 단점
    - 
    - 데이터 삽입 처음과 끝에서는 O(1) (주소를 알고 있으니까?)
#### 덱(deque)
- 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너
- 크기 제한 없다는 장점
- 연산
    - append(x): 오른쪽에 x 추가
    - popleft(): 왼쪽에서 요소를 제거하고 반환, 요소가 없으면 IndexError

```python
from collections import deque

q = deque()
q.append(1)         # enqueue()
t = q.popleft()     # dequeue()
```

- 크기가 정해진 큐일 경우 front = rear = -1 방식이 속도 면에서 유리, deque이 비슷한 속도, append-pop방식이 느림