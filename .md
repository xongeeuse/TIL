## 250120
메모리 무한 X -> 관리 필요
프로그램 종료 시 할당된 모든 메모리 날라감(정확히는 OS에 반환)

#### 데이터 무결성
- 값을 읽고 쓰는 행위 동시에 일어나면 안돼!
- 프로그램에서 동시에 한 메모리를 쓸 경우, 데이터가 깨지는 현상
- 순차적인 프로그램에서는 데이터가 깨질 수 있음
- 병렬적으로 데이터에 접근하는 multi thread 환경에서 반드시 고려해야 하는 요소
- Lock / Unlock 키워드로 관리 가능

#### 메모리의 저장 매체
- 파일 : 메모리의 데이터를 프로그램에서 직접 하드 디스크에 기록
- 데이터베이스 : 메모리의 데이터를 DBMS 등의 관리 시스템을 통해 기록
- 레지스트리 : 운영체제(OS)의 설정 및 정보가 저장되는 데이터베이스

<결론>
- 프로그래머라면 반드시 메모리에 대한 이해 필요!
- 메모리는 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있다.
- 메모리는 영구적이지 않으니 저장 매체에 기록해야 다시 꺼내 쓸 수 있다.
- 데이터 무결성에 대해 항상 주의할 것!


## 250121
### 클러스터드 인덱스 vs 논클러스터드 인덱스

#### 클러스터드 인덱스
- 기본 키(PK)나 고유한 식별자와 같은 순차적이고 고정된 값에 적합
- 테이블 당 하나만 존재
- 실제 물리 데이터의 재배열 이루어지기 때문에 대량 데이터의 경우 성능 저하될 수 있음

#### 논클러스터드 인덱스
- 데이터들의 이름이나 문자열처럼 순차적 정렬 힘든 데이터들에 적합
- 실제 물리 데이터의 재배열 일어나지 않고 별도 구조로 인덱스 저장
- 하나의 테이블에 여러 개의 논클러스터드 인덱스 생성 가능
- 인덱스 자체에 데이터가 저장되지 않고, 데이터의 위치를 가리키는 포인터 저장

#### 비교
- 클러스터드 인덱스는 범위 검색에 유리, 일반적으로 검색 속도 더 빠름
- 논클러스터드 인덱스는 특정 조건의 데이터 빠르게 찾는 데 유용하지만, 추가 저장 공간 필요
- 논클러스터드 인덱스는 데이터  삽입, 수정, 삭제 작업에서 클러스터드 인덱스보다 더 나은 성능 보일 수 있음
